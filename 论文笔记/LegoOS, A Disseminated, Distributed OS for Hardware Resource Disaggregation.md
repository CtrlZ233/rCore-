# 0 基本名词
micro-benchmark: 用来测量一个计算机系统某一特定方面（如CPU、存储器、互连网络、输入输出、操作系统等）性能的基准程序
macro-benchmark: 用来测量一个计算机系统总体性能的基准程序。

# 1 要解决什么问题
主要是当前数据中心的资源管理出现以下问题：
1. `低效的资源利用率`：非分布式应用程序只能运行在同一台物理机器上的CPU和内存中，导致资源使用不充分, 调研了Google和一个数据中心29天的利用率和阿里巴巴的一个数据中心的12小时利用率，CPU和内存利用率均只有50%左右。
2. `贫乏的硬件弹性`：当在整机中安装硬件组件后, 由于主板往往采用定制的形式,很难在往其中添加或减少新的硬件。
3. `粗粒度的故障域`：当服务器中的某个关键元件损坏后(如CPU 主板 内存 电源等)， 往往导致整个机器都无法使用, 包括其中完好的其他硬件。
4. `不能对异构进行有效支持的` ：当前服务器中不同型号的设备在主板上紧耦合在一起，当有新的硬件设备出现时，将其应用到数据中心是一个漫长的过程。

# 2 如何解决
## 2.1 几个假设
要解决以上几个问题，只有将整机完全打碎，分散成各个不同类型的设备进行管理。论文作者设想了一种硬件资源分解体系结构：传统服务器中的硬件资源通过网络进行连接而不是系统总线，每个硬件组件都有一个控制器和一个网络接口，可以独立的管理自己的资源，并且故障隔离。

上面设想的实现基于以下几个发展趋势和假设：
- 网络带宽和系统总线带宽基本持平甚至超越。
- 网络接口更加靠近硬件组件，这样硬件设备将可以直接访问网络而无需任何附加处理器。
- 硬件设备将结合更多的处理能力，允许应用程序和OS的部分逻辑功能下放到硬件。

## 2.2 SplitKernel OS Architecture
作者基于上一节设想的分布式硬件体系结构提出了一个新的OS内核结构，主要包含如下四个特征：

- 拆分OS功能体：把传统OS功能单元拆分成　`monitor` ，每个 `monitor` 管理一个硬件组件，`monitor` 之间是松耦合的，通过通信来访问远程资源，同时使用无状态设计来实现最小状态共享或元数据共享。

- 在硬件组件上运行 `monitor`：在非处理器的硬件组件（如内存、磁盘等）上有一个控制器可以运行 `monitor` 程序，这个控制器可以是低功耗的通用核心。每个 `monitor` 可以在约定的接口下使用自己的实现来管理硬件资源，这样对于新出现的硬件，开发者只需要实现对应的 `monitor` 来管理资源，并连接网络即可完成适配。

- 跨非一致性组件的消息传递：与其他分布式系统所依赖的一致性互联不同，SplitKernel的通信运行在通用网络层（如 `Ethernet`），并且为了减少网络带宽消耗不提供缓存一致性。当然，这里依然保留了硬件本身提供的一致性保证，而用户程序需要通过消息通信自己来保证所需要的一致性。（？操作系统本身不需要一些数据一致性的保障吗？）

- 全局的资源管理和错误处理：除了 `monitor` 管理自己的硬件资源外，SplitKernel还需要一个全局的资源管理，和错误处理来避免某个硬件组件挂掉导致的所有涉及到的任务失败。为了减小性能消耗，全局管理只是偶尔的和粗粒度的。

![[Pasted image 20220913165844.png]]

## 2.3 LegoOS
`LegoOS` 是论文作者实现的一个 `SplitKernel` 架构的分布式操作系统。
### 2.3.1 Design

#### 2.3.1.1 Usage Model
`LegoOS` 对用户暴露了一群虚拟节点 `vＮode` ，在用户看来，一个 `vＮode` 就是一个虚拟机，多个用户可以在同一个 `vNode` 上操作，也可以在一个 `vNode` 上运行多个任务，同时，一个 `vNode` 可以运行在多个组件上，一个组件上可以同时有多个 `vNode` ，这些执行状态对用户都是透明的。

由于 `SplitKernel` 的设计原则中包含不提供跨组件的一致性保证，因此 `LegoOS` 不支持跨进程的可写共享内存，`LegoOS` 假设只在同一进程下的线程中共享内存，而应用程序使用跨进程的可写共享内存需要通过消息通信来保证一致性。

最后，`LegoOS` 将支持Linux的基本系统调用和ABI，可以运行在Linux上的分布式应用程序同样可以运行在 `LegoOS` 上。

#### 2.3.1.2 Hardware Architecture
`LegoOS` 主要将硬件组件分为3类：处理器，内存、和存储，分别对应三种 `component` : `pComponent`（CPU）、`mComponent`（DRAＭ）、`sComponent`（SSD or ＨDD）。

![[Pasted image 20220913202511.png]]

- 分离处理器和内存功能：`LegoOS` 将所有的硬件内存功能都放到 `mComponent` （如页表，TLB），只在 `pCompenent` 中留下了一部分缓存内存（用于提速），所有的内存操作对 `pComponent` 是透明的。
- 处理器虚拟缓存：这里由于引入了 `Vritual Cache` , 会导致 `homonym problem`，通过 `ASID` 解决。
- 扩展缓存：利用局部性原理，在 `pComponent` 中保留一部分内存 `ExCache` 来提高性能。这里的 `Cache` 位于 LLC和跨组件内存之间的层级结构。每个扩展缓存行由一个指示虚拟地址的 `tag` 和两个访问权限位控制，这些由OS来进行设置，而设置一个硬件缓存控制器负责通过虚拟地址来fetch对应的缓存行，如果fetch失败，再转由OS处理。（不是很懂，如何区分不同进程的虚拟地址？）
- 在 `pComponent` 中还保留了 `LegoOS` 内核所用到的内存数据本身，确保可以直接通过物理地址访问内核数据。

#### 进程管理



# 3 结果如何
# 4 个人思考
1. 这个设计和硬件虚拟化软件如docker和k8s的区别和优劣?